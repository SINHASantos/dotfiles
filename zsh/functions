# Make a new folder and move to it right away
function take() {
    mkdir -p "$1"
    cd "$1"
}

function cmd-score() {
  cat ~/.zhistory | awk '{a[$1]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}"
  open "http://localhost:${port}/"
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# cd into whatever is the forefront Finder window.
cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# Extract archives - use: extract <file>
# Credits to http://dotfiles.org/~pseup/.bashrc
function extract() {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2) tar xjf $1 ;;
      *.tar.gz) tar xzf $1 ;;
      *.bz2) bunzip2 $1 ;;
      *.rar) rar x $1 ;;
      *.gz) gunzip $1 ;;
      *.tar) tar xf $1 ;;
      *.tbz2) tar xjf $1 ;;
      *.tgz) tar xzf $1 ;;
      *.zip) unzip $1 ;;
      *.Z) uncompress $1 ;;
      *.7z) 7z x $1 ;;
      *) echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Super fast git stuff
function g {
  if [[ $# > 0 ]]; then
    git $@
  else
    git status -sb
  fi
}
compdef g=git

function b {
  if [[ $# > 0 ]]; then
    bundle $@
  else
    bundle check > /dev/null || bundle install
  fi
}

function v {
  if [[ $# > 0 ]]; then
    vim $@
  else
    vim .
  fi
}
compdef v=vim

# Colors vary depending on time lapsed.
TIME_SINCE_COMMIT_SHORT="%{$fg[green]%}"
TIME_SHORT_COMMIT_MEDIUM="%{$fg[yellow]%}"
TIME_SINCE_COMMIT_LONG="%{$fg[red]%}"
TIME_SINCE_COMMIT_NEUTRAL="%{$fg[cyan]%}"

function minutes_since_last_commit {
  if git rev-parse --git-dir > /dev/null 2>&1; then
    now=`date +%s`
    last_commit=`git log --pretty=format:'%at' -1`
    seconds_since_last_commit=$((now-last_commit))
    minutes_since_last_commit=$((seconds_since_last_commit/60))

    echo " `pretty_print_minutes $minutes_since_last_commit`"
  fi
}

# vim_ins_mode="%{$fg[black]%}[INS]%{$reset_color%}"
vim_ins_mode=""
vim_cmd_mode="%{$fg[cyan]%}[NORM]%{$reset_color%}"
vim_mode=$vim_ins_mode

function zle-keymap-select {
  vim_mode="${${KEYMAP/vicmd/${vim_cmd_mode}}/(main|viins)/${vim_ins_mode}}"
  zle reset-prompt
}
zle -N zle-keymap-select

function zle-line-finish {
  vim_mode=$vim_ins_mode
}
zle -N zle-line-finish

# Fix a bug when you C-c in CMD mode and you'd be prompted with CMD mode indicator, while in fact you would be in INS mode
# Fixed by catching SIGINT (C-c), set vim_mode to INS and then repropagate the SIGINT, so if anything else depends on it, we will not break it
# Thanks Ron! (see comments)
function TRAPINT() {
  vim_mode=$vim_ins_mode
  return $(( 128 + $1 ))
}

function gg {
  git commit -m "$*"
}

function deploy-to-heroku() {
  heroku create
  git push heroku master
  heroku run rake db:migrate db:seed
}

function git-new-remote-tracking-branch {
  git checkout -b $1 && git push -u origin $1
}

function git_branch_name {
  val=`git branch 2>/dev/null | grep '^*' | colrm 1 2`
  echo "$val"
}

function git-on-master {
  branch=`git_branch_name`
  git checkout master && git pull --rebase 
  git checkout $branch
  git rebase master
}

function git-nuke {
  git branch -D $1
  git push origin :$1
  git branch --delete --remotes origin/$1
  git fetch origin --prune
}
compdef _git git-nuke=git-checkout

function git-rename-tag {
  git tag $2 $1
  git tag -d $1
  git push origin :refs/tags/$1
  git push --tags
}

function git-delete-remote-tag {
  git push origin :refs/tags/$1
}

function rem {
  mv -f ./$1 ~/.Trash
}

if [ $(uname) = "Linux" ]; then
  function open {
    if (echo $1 | grep ".pdf" > /dev/null); then
      pdf $1
    elif (echo $1 | grep ".png" > /dev/null); then
      feh $1
    elif (echo $1 | grep ".jpg" > /dev/null); then
      feh $1
    elif (echo $1 | grep ".jpeg" > /dev/null); then
      feh $1
    else
      vim $1
    fi
  }
fi

function pdf {
  zathura --fork $1 > /dev/null 2>&1
}

function rm-pwd {
  current_folder=`pwd | grep -o '[^/]*$'`
  cd ..
  rem ./$current_folder
}

function repeat {
  n=$1
  shift
  while [ $(( n -= 1 )) -ge 0 ]; do
    "$@"
  done
}

# fh - repeat history
fh() {
  eval $(([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s | sed 's/ *[0-9]* *//')
}

# fkill - kill process
fkill() {
  ps -ef | sed 1d | fzf -m | awk '{print $2}' | xargs kill -${1:-9}
}

# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fe() {
  local file
  file=$(fzf --query="$1" --select-1 --exit-0)
  [ -n "$file" ] && ${EDITOR:-vim} "$file"
}

# fd - cd to selected directory
fd() {
  local dir
  dir=$(find ${1:-*} -path '*/\.*' -prune \
                  -o -type d -print 2> /dev/null | fzf +m) &&
  cd "$dir"
}

cdp() {
  cd `pbpaste`
}

rakez() {
  rake `rake -T | sed "s/#.*//" | cut -f 2 -d ' ' | fzf`
}

gaz() {
  git add `git_stageable_files | fzf`
}

gapz() {
  git add --patch `git_stageable_files | fzf`
}

# Colored man pages
man() {
  env LESS_TERMCAP_mb=$'\E[01;31m' \
  LESS_TERMCAP_md=$'\E[01;38;5;74m' \
  LESS_TERMCAP_me=$'\E[0m' \
  LESS_TERMCAP_se=$'\E[0m' \
  LESS_TERMCAP_so=$'\E[38;5;246m' \
  LESS_TERMCAP_ue=$'\E[0m' \
  LESS_TERMCAP_us=$'\E[04;38;5;146m' \
  man "$@"
}

brew_search_and_install() {
  brew install $(brew search $1 | vipe)
}

# vi: ft=sh
